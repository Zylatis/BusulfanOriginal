#workDir<-"/home/graeme/Dropbox/Thymic Development/BusulfanProjectFiles/"
workDir<-"C:/Users/Graeme/Dropbox/Thymic Development/BusulfanProjectFiles"
setwd(workDir)
E<-exp(1)
source("BusulfanPackages.R")


##########################################################################################################################################################################################################

#Code for bootstrapping naive busulfan data
#User must ensure the following is correct
cell<-"8nai"
precursor<-paste("sp",substr(cell,1,1),sep="")
precursor<-"sp8"
qZero<-1

#requires folder ROutputs/ exists
##########################################################################################################################################################################################################

#This code will take in the outputs (except ki67 stuff) of DataPrepare.R and output the best fit and some number of bootstrap replicates.

#The bootstrapping is setup as follows:
#First the precursor (SP4/SP8) is fitted to extract nu. This is then used as an input into the peripheral fits where the donor fraction and total counts are fitted simultaneously using 
#the GenSA to minimize the sum of squares.
#Currently the counts are log transformed and the donor fraction is transformed using ArcSinSqrt.
#This is all editable below.

##########################################################################################################################################################################################################

#Find number of cores, leave one spare
nLogicalCores<-detectCores(all.tests = FALSE, logical = TRUE) -1
#setwd("C:/Users/Graeme/Dropbox/Thymic Development/Current/Bootstrap and analysis code/SelfContained")

#import data
dataFolder<-"PreparedDataR/"
countData <- read.table(paste(dataFolder,cell,"TotalCounts.txt",sep=""), sep="\t")
ratioData <-read.table(paste(dataFolder,cell,"SPRatio.txt",sep=""), sep="\t")
precursorData <-read.table(paste(dataFolder,precursor,"TotalCounts.txt",sep=""), sep="\t")

#get rid of all data prior to reconstitution and shift everything so that we start at t = 0
reconstitution.time<-42 #days
apply.reconstitution.time<-function(set){
  temp<-set[set$V1>=reconstitution.time,]
  temp[,1]<-temp[,1]-reconstitution.time

  assign(deparse(substitute(set)),temp,envir=.GlobalEnv)
}

apply.reconstitution.time(countData)
apply.reconstitution.time(ratioData)
apply.reconstitution.time(precursorData)

#define timepoint vectors
tVec<-countData[,1]
precursor.tVec<-precursorData[,1]

# #stupid windows factor conversion shit
# ratioData[,2]<-as.numeric(as.character(ratioData[,2]))

#scale N0 by 10^7 to make fitting easier
countData[,2] <-countData[,2]/10^7

##########################################################################################################################################################################################################

#define transforms
T1 <- function(x) { #used for counts
log(x)
}

T2 <- function(x) { #used for rescaled donor frac
  asin(sqrt(x))
}
##########################################################################################################################################################################################################

#define analytic fitting functions
#these are the functions that are fitted to the data. 'q' here is left free but is currently set to zero in the
#SSR finding function (can be made free again to check if q!=0 gives superior AIC)
ratioFn<-function(t,pars){
  #x1<-with(pars,(lambda-nu)*(1+exp((1-q)*lambda*t)*alpha-mu))
  #x2<-with(pars,(exp(t*(lambda-nu))-1)*TonN+(lambda-nu)*mu)
  #return(1/(1+x1/x2))
  x1<-with(pars,1/(1 - ((-1 - alpha/exp(lambda*(-1 + q)*t) + mu)*(lambda - nu))/(mu*(lambda - nu) + (-1 + exp((lambda - nu)*t))*TonN)))
  return(x1)
}

totalCountFn<-function(t,pars){
  with(pars,(N0*(alpha*exp(lambda*t)*(lambda - nu) + exp(lambda*q*t)*(lambda - nu - TonN) + exp((lambda - nu + lambda*q)*t)*TonN))/(exp(lambda*(1 + q)*t)*(lambda - nu)))
}

##########################################################################################################################################################################################################

#functions below are split - could be done all in one go but this way we can call other functions later without worrying about local and global variables so much

#SSRfn is called directly from the SimulatedAnnealing (GenSA) function. 
# inVec is a vector of parameter values generated by GenSA, cDat and rDat are the TRANSFORMED count and ratio data sets, and nuVal is the value of nu calculated from SP4/8
SSRfn<-function(inVec,cDat,rDat,nuVal){
  residuals<-residFn(inVec,cDat,rDat,nuVal)
  SSRc<-sum(residuals[[1]]^2)
  SSRr<-sum(residuals[[2]]^2)
  SSR<-SSRr*SSRc
  if(SSR<SSRbest){
    SSRbest<<-SSR
  }
#  if(SSR=="NaN"){ browser() } #keeps track of nastiness. In principle errors can be thrown by ratio~1.0001 thus breaking asin(sqrt(x)). In other codes added tolerance to send 1+delta->1. but doesn't seem an issue here (perhaps in bootstrap?)
  return(SSR)
}

#function to calculate transformed points given a set of parameters
TransformFunctions<-function(inVec,nu){
   pars<-c(nu,inVec)
   names(pars)<-header
   pars<-as.data.frame(t(pars))
   
   countVals<-totalCountFn(tVec,pars)
   ratioVals<-ratioFn(tVec,pars)
   ratioVals[ratioVals>1]<-1. # assumption here being that any values >1 are from numeric instabilities and not because the model is totally fucked.
   
   countFnP<-T1(countVals)
   ratioFnP<-T2(ratioVals)
  return(list(countFnP,ratioFnP))
}

#calculate residuals
residFn<-function(parameters,cDat,rDat,nuVal){
  
  #call function to get transformed function values
  transformedFns<-TransformFunctions(parameters,nuVal)
  #fn minus data
  #recall dataVec inputs are defined on the TRANSFORMED scale, so only need to transform fitted values here.
  residC<-(transformedFns[[1]]-cDat)
  residR<-(transformedFns[[2]]-rDat)

  return(list(residC,residR))
  
}
##########################################################################################################################################################################################################
findFit<-function(dVec,nuVal){
  require(doParallel)
  #  q doesn't appear as is explicitly set to zero in global environment below.
  #  if relaxed, need to add q back here. Can easily make a more general system, but seems to be slower in actual computation so a trade off between modularity and speed

  #internal numeric toggles
  global.min <- 0
  tol <- 1e-5
  maxit<-3*10^3
  temp<-10^6

  out <- GenSA(par=start,lower = lower, upper = upper, fn = SSRfn, control=list(verbose=TRUE,temperature=temp,nb.stop.improvement=1000,maxit=maxit),dVec[[1]],dVec[[2]],nuVal)
  fitPars<-out["par"][[1]]
  return(fitPars)
  
}
##########################################################################################################################################################################################################
#BUILD UP PARAMETER SET

header<-c("nu","lambda","N0","TonN","alpha","mu") # minimum header - need at least all these parameters
#numeric toggles for GenSA funciton
dimension <- 5 #fit nu separately, hence why dimension is only 5!
start<-  c(0.1,   3,   0.1,   0.1,   0.1)
upper <- c(1,   10,   1,   1,   1)
lower <- rep(10^-5, dimension) #  having things be zero causes headaches! best to have a small offset.

#now decide if we want to add more in the form of q
if(qZero==1){
  q<-0 # current setting. if you want q to be free, add it to header below and add limits in the 'start' and 'upper' vectors and change dimension to 6 

} else if(qZero==0){
  invisible(rm(q)) #may cause errors if q not yet declared, ignore/suppress
  header<-c(header,"q")

  start<-  c(start,0.1)
  upper <- c(upper,10)
  lower <- c(lower,0)
}
##########################################################################################################################################################################################################
#GET BEST FIT TO PRECURSOR FUNCTION TO EXTRACT NU
#fitting on a log scale (counts)
# 7th Dec 2015 make new tvec precursor.tVec for precursor fits. This means that the bootstrap will fail as assumes same number of rows in precursor as peripheral. need to fix this!
precursorFit<-nls(T1(precursorData[,2])~logA-precursor.tVec*nu, start=list(logA=10,nu=0.1))
nuVal<-coef(precursorFit)[[2]]

##########################################################################################################################################################################################################
#BEGIN REST OF FITTING ROUTINE

#define large SSRbest to be swapped out in if-statement to keep track of how well GenSA settles on final minimum
SSRbest<-10^6

#transform experiment data
dataVec<-list(T1(countData[,2]),T2(ratioData[,2]))

#run best fit code
system.time(bestFitPars<-findFit(dataVec,nuVal))

#re-run with best fit parameters to ensure at minimum
bestFitSSR<-SSRfn(bestFitPars,dataVec[[1]],dataVec[[2]],nuVal)

#combine best fit parameters to export
exportBF<-rbind(c(nuVal,bestFitPars))
colnames(exportBF) <- header

#output best fit data
write.xlsx(x = exportBF, file = paste("ROutputs/RCD",cell,"best.xlsx",sep=""),
           sheetName = "Results", row.names = FALSE)

#get TRANSFORMED best-fit values of all three cases (precursor, peripheral count and ratio)
TprecursorBF<-predict(precursorFit) 
TperipheralBF<-TransformFunctions(bestFitPars,nuVal)

#use this to calculate precursor residuals to be bootstrapped along with the count data
precursorResids<-TprecursorBF-T1(precursorData[,2])
residuals<-residFn(bestFitPars,dataVec[[1]],dataVec[[2]],nuVal)

# 7th Dec 2015 - decoupled precursor resids from peripheral resids so we can deal with things like gdT44lo and EM/CM where we have different number of points in periphery compared to thymus
#combine all into single dataframe - keeps mice paired across cell types
pairedMice<-data.frame(residuals[[1]],residuals[[2]]) 

##########################################################################################################################################################################################################
#number of bootstrap replicates
n.Replicates<-1
residual.choice.set<-foreach(i = 1:n.Replicates,.combine='rbind') %do% {
  #choose residuals with replacement
  precursorChoice<-precursorResids[sample(1:length(precursorResids),replace=TRUE)]
  peripheralChoice<-pairedMice[sample(1:length(pairedMice[,1]),replace=TRUE),]
  list(precursorChoice,peripheralChoice[[1]],peripheralChoice[[2]])
}
#define bootstrap functon
doBoot<-function(i){
  # get master residual list from pre-prepared table
  residual.choice<-residual.choice.set[i,]
  
  #make new precursor, count, and ratio data (best fit + residuals)
  newPrecursor<-TprecursorBF+residual.choice[[1]]
  
  newCounts<-TperipheralBF[[1]]+residual.choice[[2]]
  newRatio<-TperipheralBF[[2]]+residual.choice[[3]]
  #fit new precursor to get new nu
  precursorBoot<-nls(newPrecursor ~ logA-precursor.tVec*nu, start=list(logA=10,nu=0.1))
  nuBoot<-coef(precursorBoot)[[2]]
  
  newDat<-list(newCounts,newRatio)

  #return new nu, and also fit on count and ratio with this new nu
  return(c(nuBoot,findFit(newDat,nuBoot)))
  
}
# 
# 
# print("Start bootstrap")
# #make parallel cluster thing
# cl <- makeCluster(nLogicalCores)
# registerDoParallel(cl)
# ls<-foreach(i = 1:n.Replicates, .combine='rbind',.export='precursor.tVec') %dopar% {
#   library(GenSA)
#   doBoot(i)
# }
# colnames(ls) <- header
# stopCluster(cl)
# 
# #output bootstrap data
# write.xlsx(x = ls, file = paste("ROutputs/RCD",cell,"Boot.xlsx",sep=""),
#            sheetName = "Results", row.names = FALSE)

######################################################################################################
plot.times<-seq(1:350)
global.theme<-theme(axis.title = element_text(family = "Helvetica", color="#666666", face="bold", size=15)) +theme(plot.title = element_text(family = "Helvetica", color="#666666", face="bold", size=15, hjust=0)) +theme(axis.text.x=element_text(size=15) ,axis.text.y=element_text(size=15))

ratio.vals<-sapply(plot.times,ratioFn,as.data.frame(exportBF))
counts.vals<-sapply(plot.times,totalCountFn,as.data.frame(exportBF))
plot.data<-data.frame(t=plot.times,ratio=ratio.vals,counts=counts.vals)
donor.frac.plot<-ggplot(plot.data,aes(t,ratio))+geom_line()+geom_point(data=ratioData,aes(V1,V2))+ylim(c(0,1))+global.theme+labs(x="t (days post BMT)",y="Donor frac")+ggtitle(paste(cell," with ",precursor," precursor",sep=""))
total.counts.plot<-ggplot(plot.data,aes(t,counts))+geom_line()+geom_point(data=countData,aes(V1,V2))+ylim(c(0,5))+global.theme+labs(x="t (days post BMT)",y="Total counts (10^-7)")+ggtitle(paste(cell," with ",precursor," precursor",sep=""))

pdf(file=paste("ROutputs/",cell,"RatioPlot.pdf",sep=""),width=10, height=6, onefile=FALSE)
donor.frac.plot
dev.off()

pdf(file=paste("ROutputs/",cell,"CountsPlot.pdf",sep=""),width=10, height=6, onefile=FALSE)
total.counts.plot
dev.off()